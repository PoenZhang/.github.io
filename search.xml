<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="2020/10/29/EXPALIN/"/>
      <url>2020/10/29/EXPALIN/</url>
      
        <content type="html"><![CDATA[<hr><p>title: 如何使用SQL的EXPLAIN指令判断和优化SQL性能？<br>date: 2020-10-29 16:01:00<br>author: PoenZhang<br>img: <a href="https://s1.ax1x.com/2020/10/29/BGoOgS.jpg">https://s1.ax1x.com/2020/10/29/BGoOgS.jpg</a><br>top: true<br>cover: true<br>summary: SQL的EXPLAIN指令<br>categories: 数据库<br>tags:</p><ul><li>MySQL</li><li>ORACLE</li></ul><hr><p>工作中，我们经常会写一些很复杂的SQL，有可能是统计报表，有可能是复杂查询，当我们费尽手段把一个可以工作的SQL写出来之后，并不意味着结束了，如果这个SQL查询或者统计速度很慢，将是一个十分耗费资源的动作。即使它能工作，也有可能在执行半分钟或者更久之后能够给出结果，但执行时间越久，耗费资源就越多，越容易阻塞后续的数据库链接请求，如果这样的SQL很多，那么最终也将拖垮服务器。</p><h3 id="EXPALIN指令"><a href="#EXPALIN指令" class="headerlink" title="EXPALIN指令"></a>EXPALIN指令</h3><p>SQL为什么会执行的慢？该如何判断这个SQL的查询数量级？我们可以用 “EXPLAIN”指令，解释你的SQL。</p><p>EXPLAIN指令是一个优化神器，虽然它并不能直接告诉你该如何优化这个SQL，但是你可以根据它对你SQL的模拟执行得到你的SQL有没有用上索引，有没有做全表扫描，查询出结果的数量级是多少。这是一个基于开销的优化器，我们可以获得更多被优化器考虑到的访问策略的细节，以及当运行SQL语句时，哪种策略预计会被采用。</p><pre><code>mysql&gt; explain select * from servers;+----+-------------+---------+------+---------------+------+---------+------+------+-------+| id | select_type | table   | type | possible_keys | key  | key_len | ref  | rows | Extra |+----+-------------+---------+------+---------------+------+---------+------+------+-------+|  1 | SIMPLE      | servers | ALL  | NULL          | NULL | NULL    | NULL |    1 | NULL  |+----+-------------+---------+------+---------------+------+---------+------+------+-------+row in set (0.03 sec)</code></pre><p>我们做了一个简单的例子，我们可以看到explain的用法就是 “explain 目标SQL”，得出的结果有10列，如上代码块，我们会挨个解释这些列的意义。</p><h4 id="1、id"><a href="#1、id" class="headerlink" title="1、id"></a>1、id</h4><p>这个id并不是表中记录的id，而是查询语句或者操作表的顺序，包含几种情况</p><p>id相同时，执行顺序由上到下</p><p>id不同，如果是子查询，id序号会递增，id越大优先级越高，越先被执行</p><p>id既有相同的，也有不同的。id相同的被认为是一组，顺序从上到下；在所有组中，id越大优先级越高。</p><h4 id="2、select-type"><a href="#2、select-type" class="headerlink" title="2、select type"></a>2、select type</h4><p>表示查询中每个select字句的类型</p><p>（1）simple：简单select，不使用union或子查询等</p><p>（2）primary：查询中若包含任何复杂的子部分，最外层的select会被标记为primary</p><p>（3）union：union中的第二个或者后边的select语句</p><p>（4）subquery：在select或者where中包含了子查询</p><p>（5）derived：在from列表中包含的子查询被标记为derived（衍生表），mysql会递归这些子查询并放到临时表中</p><p>（6）union result:从union表中获取select查询的结果</p><h4 id="3、table"><a href="#3、table" class="headerlink" title="3、table"></a>3、table</h4><p>标识这一行的数据是关于哪一张表的，有的时候并不是真实的表名，比如是derived衍生表</p><pre><code>mysql&gt; explain select * from (select * from ( select * from t1 where id=2602) a) b;+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+| id | select_type | table      | type   | possible_keys     | key     | key_len | ref  | rows | Extra |+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+|  1 | PRIMARY     | &lt;derived2&gt; | system | NULL              | NULL    | NULL    | NULL |    1 |       ||  2 | DERIVED     | &lt;derived3&gt; | system | NULL              | NULL    | NULL    | NULL |    1 |       ||  3 | DERIVED     | t1         | const  | PRIMARY,idx_t1_id | PRIMARY | 4       |      |    1 |       |+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+</code></pre><h4 id="4、type"><a href="#4、type" class="headerlink" title="4、type"></a>4、type</h4><p>表示在表中找到所需行的方式，又叫做访问类型。常用的类型由：all，index，range，ref，eq_ref，const，system，null（性能从差到好）</p><p>all:：全表扫描</p><p>index：index和all的区别是index只遍历索引树</p><p>range：只检索给定范围的行记录，使用一个索引来选择行</p><p>ref：表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p><p>eq_ref：跟ref类似，区别在于使用的索引是唯一索引</p><p>sonst，system：当SQL对查询部分进行优化，并转换为一个常量时，使用这些类型访问。</p><p>null：在优化过程中分解语句，执行时甚至不用访问表或者索引。例如从一个索引列中选取最小值可以单独通过索引查找完成。</p><h4 id="5、possible-keys"><a href="#5、possible-keys" class="headerlink" title="5、possible_keys"></a>5、possible_keys</h4><p>指出能使用哪个索引在表中找到记录，查询涉及的字段若存在索引，会在这一列列出来，但不一定会用到该索引。</p><p>如果该列是null，就说明没有用到任何索引，这时候你可能需要观察表中的查询高频列增加索引，然后在explain看下结果</p><h4 id="6、keys"><a href="#6、keys" class="headerlink" title="6、keys"></a>6、keys</h4><p>显示实际决定使用的索引列</p><p>如果没有选择到索引，则是null。如果要强制使用某个索引，需要在查询中加语句：force index，use index。如果不想使用某索引，可以使用 ignore index </p><h4 id="7、key-len"><a href="#7、key-len" class="headerlink" title="7、key_len"></a>7、key_len</h4><p>表示索引中使用的字节数，可以通过该列计算查询中使用的索引长度</p><h4 id="8、ref"><a href="#8、ref" class="headerlink" title="8、ref"></a>8、ref</h4><p>表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。</p><h4 id="9、rows"><a href="#9、rows" class="headerlink" title="9、rows"></a>9、rows</h4><p>标识此次查询根据表统计信息及索引选用情况，估算到的找到符合条件的记录所需要读取的行数</p><h4 id="10、extra"><a href="#10、extra" class="headerlink" title="10、extra"></a>10、extra</h4><p>包含此次查询的详细信息：</p><p>using filesort：表明此次查询会使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。查询中无法利用索引完成的排序被称为文件排序</p><p>using temporary：此次查询使用到了临时表保存中间结果，常见于order by和group by</p><p>using index：表明此次查询实用到了覆盖索引，避免了全表扫描</p><p>using where：表明此次查询where的条件里边，有索引值存在，使用到了索引去查询</p><p>using join buffer：使用了链接缓存</p><p>impossible where：where条件里边总是false，不能用来获取任何记录</p><p>select tables optimized away：这意味着仅通过使用索引，优化器可能仅从聚合函数中返回一行</p><p>explain指令，不会考虑各种cache，也不会告诉你它做了什么优化，也只能支持select操作，部分的统计信息是估算的，并非精确值。</p><p>我们使用explain的时候，在大部分情况下都是要关注：<strong>possible_keys，**</strong>Key，**<strong>rows，**</strong>Extra<strong>这四项，关注此次查询</strong>是否用到了索引，大约查询的数据在什么量级，额外用到了哪些东西**，这是我们着重优化的点。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库事务隔离级别</title>
      <link href="2020/10/29/data_transaction/"/>
      <url>2020/10/29/data_transaction/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是事务隔离？"><a href="#什么是事务隔离？" class="headerlink" title="什么是事务隔离？"></a>什么是事务隔离？</h3><p>任何支持事务的数据库，都必须具备四个特性：原子性，一致性，隔离性，永久性，也就是ACID，这样才能保证事务中数据的正确性。</p><p>而事务的隔离性就是指：多个并发的事务同事访问一个数据库时，一个事务不应该被另一个事务所干扰，每个并发的事务都要相互隔离。</p><h3 id="如果没有事务隔离"><a href="#如果没有事务隔离" class="headerlink" title="如果没有事务隔离"></a>如果没有事务隔离</h3><p>如果没有事务隔离的话，会发生什么？</p><p>假设有表T，里边记录了几种语言的记录</p><table><thead><tr><th>ID</th><th>NAME</th></tr></thead><tbody><tr><td>1</td><td>JavaWeb</td></tr><tr><td>2</td><td>Python</td></tr><tr><td>3</td><td>Go</td></tr></tbody></table><p>（1）事务A访问数据库，向表中插入了一条记录4:C++，但是并没有提交事务</p><p>insert into T values(4,’C++’)；</p><p>这时候，来了一个事务B，要查询表中所有的记录，这是就能查到id为4的C++，这种情况叫做“脏读”</p><p>（2）事务A访问数据库，要按id查询id为1的语言的名字，执行了：</p><pre><code>select * from T where id = 1;</code></pre><p>得到了name为JavaWeb的记录。这时候事务B访问数据库，将id为1的记录的name更新为了JavaEE</p><pre><code>update T set name = 'JavaEE' where id = 1;</code></pre><p>接着事务A还想再看一次id为1的记录的name，发现已经变成了JavaEE，跟第一次的读取数据不同，这就叫做不可重复读。</p><p>（3）事务A访问数据库，想看表中的记录都有什么，于是执行了：</p><pre><code>select * from T;</code></pre><p>这时候，事务B来了，向表中插入了一条新的记录：</p><pre><code>insert into A values(5,'SQL');</code></pre><p>然后事务A想再查看一遍刚才的语言都有哪些，于是把刚才的查询语句又执行了一遍，结果第一次查询有四条，第二次查询有五条。这叫幻读。</p><h3 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h3><p>为了解决以上 脏读，不可重复读，幻读的问题，我们需要根据我们的实际情况来设置数据库的隔离级别：</p><ul><li>读未提交</li><li>读提交</li><li>可重复读</li><li>串行化</li></ul><p>这四种隔离级别对应着三种事务隔离问题，下面看一下具体解释：</p><h4 id="（1）读未提交"><a href="#（1）读未提交" class="headerlink" title="（1）读未提交"></a>（1）读未提交</h4><p>就是可以读到未提交的内容。因此在这种级别下，是不会加锁的，就会导致脏读的情况，当然了，也会出现不可重复读和幻读。</p><h4 id="（2）读提交"><a href="#（2）读提交" class="headerlink" title="（2）读提交"></a>（2）读提交</h4><p>就是只能读到事务已经提交的内容。这是各种系统中最常用的一种隔离级别。包括SQL Server和Oracle。这种隔离级别可以避免脏读。</p><p>这个级别也可以叫做“快照读”，这是按照原理来命名的，即：是事务中的每个 sql 语句生成一个 readView。那就是一个事务内多条 sql 语句，会生成多个 readView。而每条 sql 执行时，都是查询最新 readView 的值，从而查取到别的事务已经提交的数据。</p><p>但是读已提交只能避免脏读，而无法解决不可重复读和幻读。</p><h4 id="（3）可重复读"><a href="#（3）可重复读" class="headerlink" title="（3）可重复读"></a>（3）可重复读</h4><p>专门针对不可重复读的隔离级别，是MySQL的默认隔离级别。</p><p>在这个级别下，普通的查询依然是快照读，但是在事务启动时，就不允许修改（Update）操作了，而不可重复读正是因为两次读取之间出现了数据的修改操作，读取之后就加锁不允许其他事务修改这种操作效率也比较差，而成熟的数据库，出于性能考虑，都是使用了以乐观锁为理论基础的<strong>MVCC（多版本并发控制）</strong>来实现。</p><p>此级别不可避免幻读，因为幻读是由于插入（insert）或者删除（delete）操作产生的。</p><h4 id="（4）串行化"><a href="#（4）串行化" class="headerlink" title="（4）串行化"></a>（4）串行化</h4><p>  这是数据库的最高隔离级别，在这种级别下，事务串行化的顺序执行。但是效率太差，基本不会使用。</p><p><strong>脏读：select问题</strong></p><p><strong>不可重复读：update问题</strong></p><p><strong>幻读：insert/delete问题</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> ORACLE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的个人博客</title>
      <link href="2020/10/28/first/"/>
      <url>2020/10/28/first/</url>
      
        <content type="html"><![CDATA[<p>欢迎大家来到我的个人博客，让我们一起学习一起进步。</p><a id="more"></a><p>我将在此更新包括但不限于：编码，设计，数据库，随笔类型的内容；如果有想和我探讨的内容，请返回首页查找合适的联系方式联系我吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> keep learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>限流算法解析</title>
      <link href="2020/10/28/current-limiting-algorithm/"/>
      <url>2020/10/28/current-limiting-algorithm/</url>
      
        <content type="html"><![CDATA[<p>引言：盘点一下常用的几种限流算法的原理与实现。</p><a id="more"></a><h2 id="1、固定时间窗口限流"><a href="#1、固定时间窗口限流" class="headerlink" title="1、固定时间窗口限流"></a>1、固定时间窗口限流</h2><p>​        固定时间窗口限流很好理解，就是使用计数器在周期内累加访问次数，当请求次数达到设定的限流值时，触发限流策略。下一个周期开始时，将计数器清零，重新计数。这种算法是限流算法中最简单的一种，无论理解还是实现。<strong>我们可以使用Redis的incr原子自增和线程安全实现</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1500511/1599120998722-dc689c17-7cc4-4b7b-ac4b-b1409ca2e224.png" alt="image.png"></p><p>​        这个算法通常用于QPS限流和统计访问总量，但对于限制粒度较大的情况下会有比较严重的临界问题：当上一个周期的100次请求在最后10ms内抵达，当前周期的100个请求在本秒的开头10ms内抵达，我们放大到周期来看，每个周期都只有100的请求量，未触发我们的限流策略，但是缩小到上个周期的最后10ms和本周期的开头10ms来看，服务器在20ms内接收到了200个请求，这个请求量超出了我们设定的限流数量，但却没有触发限流策略。</p><p>由此可见，固定时间窗口限流算法，对于粒度较大的限流周期来说，有很大的弊端。</p><h2 id="2、滑动时间窗口限流"><a href="#2、滑动时间窗口限流" class="headerlink" title="2、滑动时间窗口限流"></a>2、滑动时间窗口限流</h2><p>​        第二种是滑动时间窗口限流算法，这种算法将时间周期分为N个小周期，分别记录每个小周期内的访问次数，并且根据时间删除过期周期访问次数的记录。</p><p>如图，假设将时间周期设置为1min，我们可以将1min再划分为2个小周期，统计每个小周期内的访问次数，则可以看到，第一个周期的访问次数为75，第二个周期超过了我们限制的100，则会触发限流策略</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1500511/1599121613919-72d66c69-5832-495a-b604-0eb8260e7e76.png" alt="image.png"></p><p>由此可见，当滑动窗口划分的格子越细致，那么滑动窗口的滚动就会越平滑，限流的统计就会越精确。</p><h2 id="3、令牌桶限流"><a href="#3、令牌桶限流" class="headerlink" title="3、令牌桶限流"></a>3、令牌桶限流</h2><p>​        令牌桶也比较简单，是以程序以一个固定的速度S（S=时间周期/限流值）向令牌桶中增加令牌，直至令牌桶满，请求到达时先到令牌桶中请求令牌，获取到令牌则通过请求，否则触发限流</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1500511/1599122374364-3bb91b33-8cdb-4dcc-b574-4a965e5f8b4d.png" alt="img"></p><h2 id="4、漏桶限流"><a href="#4、漏桶限流" class="headerlink" title="4、漏桶限流"></a>4、漏桶限流</h2><p>​        漏桶限流又被成为漏斗限流，我们将访问请求直接放入漏桶，如当前容量已经达到上限，则直接触发限流。漏桶以固定的速率进行释放访问请求（即允许请求通过），直到漏桶为空。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1500511/1599122555655-41550a62-f23f-4ba6-90eb-14469639a719.png" alt="img"></p><p>附上java版的实现：</p><pre><code>/** * Created by zhangbw */public class FunnelRateLimiter {    static class Funnel {        int capacity;   //容量        float leakingRate; //速率        int leftQuota;//剩余容量        long leakingTs;//上次漏水的时间        public Funnel(int capacity, float leakingRate) {            this.capacity = capacity;            this.leakingRate = leakingRate;            this.leftQuota = capacity;            this.leakingTs = System.currentTimeMillis();        }        void makeSpace() {            long nowTs = System.currentTimeMillis();            long deltaTs = nowTs - leakingTs;//距离上一次漏水过去了多长时间            int deltaQuota = (int) (deltaTs * leakingRate);//可以腾出多少空间            //间隔时间太长 ，整数数字过大溢出            if (deltaQuota &lt; 0) {                this.leftQuota = capacity;                this.leakingTs = nowTs;                return;            }                //腾出空间太小 ，最小单位是1                if (deltaQuota &lt; 1) {                    return;                }                this.leftQuota += deltaQuota;                this.leakingTs = nowTs;                if (this.leftQuota &gt; this.capacity) {                    this.leftQuota = this.capacity;                }            }        boolean watering(int quota) {            makeSpace();            if (this.leftQuota &gt;= quota) {                this.leftQuota -= quota;                return true;            }            return false;        }        private Map&lt;String, Funnel&gt; funnels = new HashMap&lt;&gt;();        public boolean isActionAllowed(String userId, String actionKey, int capacity, float leakingRate) {            String key = String.format("%s:%s", userId, capacity);            Funnel funnel = funnels.get(key);            if (funnel == null) {                funnel = new Funnel(capacity, leakingRate);                funnels.put(key, funnel);            }            return funnel.watering(1); //需要 1 个 quota        }    }}</code></pre><p>Redis4.0为我们提供了一个限流的Redis模块，叫做<a href="https://github.com/brandur/redis-cell">Redis-Cell</a>，该模块使用了漏斗算法，并提供了原子的限流指令。我们可以直接使用。</p><p>Guava包其实对各种限流策略都有实现，详情可见：<a href="https://guava.dev/releases/19.0/api/docs/index.html?com/google/common/util/concurrent/RateLimiter.html">RateLimiter</a></p>]]></content>
      
      
      <categories>
          
          <category> 编码与设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
            <tag> java </tag>
            
            <tag> 限流 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
