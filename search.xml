<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据库事务隔离级别</title>
      <link href="2020/10/29/data_transaction/"/>
      <url>2020/10/29/data_transaction/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是事务隔离？"><a href="#什么是事务隔离？" class="headerlink" title="什么是事务隔离？"></a>什么是事务隔离？</h3><p>任何支持事务的数据库，都必须具备四个特性：原子性，一致性，隔离性，永久性，也就是ACID，这样才能保证事务中数据的正确性。</p><p>而事务的隔离性就是指：多个并发的事务同事访问一个数据库时，一个事务不应该被另一个事务所干扰，每个并发的事务都要相互隔离。</p><h3 id="如果没有事务隔离"><a href="#如果没有事务隔离" class="headerlink" title="如果没有事务隔离"></a>如果没有事务隔离</h3><p>如果没有事务隔离的话，会发生什么？</p><p>假设有表T，里边记录了几种语言的记录</p><table><thead><tr><th>ID</th><th>NAME</th></tr></thead><tbody><tr><td>1</td><td>JavaWeb</td></tr><tr><td>2</td><td>Python</td></tr><tr><td>3</td><td>Go</td></tr></tbody></table><p>（1）事务A访问数据库，向表中插入了一条记录4:C++，但是并没有提交事务</p><p>insert into T values(4,’C++’)；</p><p>这时候，来了一个事务B，要查询表中所有的记录，这是就能查到id为4的C++，这种情况叫做“脏读”</p><p>（2）事务A访问数据库，要按id查询id为1的语言的名字，执行了：</p><pre><code>select * from T where id = 1;</code></pre><p>得到了name为JavaWeb的记录。这时候事务B访问数据库，将id为1的记录的name更新为了JavaEE</p><pre><code>update T set name = 'JavaEE' where id = 1;</code></pre><p>接着事务A还想再看一次id为1的记录的name，发现已经变成了JavaEE，跟第一次的读取数据不同，这就叫做不可重复读。</p><p>（3）事务A访问数据库，想看表中的记录都有什么，于是执行了：</p><pre><code>select * from T;</code></pre><p>这时候，事务B来了，向表中插入了一条新的记录：</p><pre><code>insert into A values(5,'SQL');</code></pre><p>然后事务A想再查看一遍刚才的语言都有哪些，于是把刚才的查询语句又执行了一遍，结果第一次查询有四条，第二次查询有五条。这叫幻读。</p><h3 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h3><p>为了解决以上 脏读，不可重复读，幻读的问题，我们需要根据我们的实际情况来设置数据库的隔离级别：</p><ul><li>读未提交</li><li>读提交</li><li>可重复读</li><li>串行化</li></ul><p>这四种隔离级别对应着三种事务隔离问题，下面看一下具体解释：</p><h4 id="（1）读未提交"><a href="#（1）读未提交" class="headerlink" title="（1）读未提交"></a>（1）读未提交</h4><p>就是可以读到未提交的内容。因此在这种级别下，是不会加锁的，就会导致脏读的情况，当然了，也会出现不可重复读和幻读。</p><h4 id="（2）读提交"><a href="#（2）读提交" class="headerlink" title="（2）读提交"></a>（2）读提交</h4><p>就是只能读到事务已经提交的内容。这是各种系统中最常用的一种隔离级别。包括SQL Server和Oracle。这种隔离级别可以避免脏读。</p><p>这个级别也可以叫做“快照读”，这是按照原理来命名的，即：是事务中的每个 sql 语句生成一个 readView。那就是一个事务内多条 sql 语句，会生成多个 readView。而每条 sql 执行时，都是查询最新 readView 的值，从而查取到别的事务已经提交的数据。</p><p>但是读已提交只能避免脏读，而无法解决不可重复读和幻读。</p><h4 id="（3）可重复读"><a href="#（3）可重复读" class="headerlink" title="（3）可重复读"></a>（3）可重复读</h4><p>专门针对不可重复读的隔离级别，是MySQL的默认隔离级别。</p><p>在这个级别下，普通的查询依然是快照读，但是在事务启动时，就不允许修改（Update）操作了，而不可重复读正是因为两次读取之间出现了数据的修改操作，读取之后就加锁不允许其他事务修改这种操作效率也比较差，而成熟的数据库，出于性能考虑，都是使用了以乐观锁为理论基础的<strong>MVCC（多版本并发控制）</strong>来实现。</p><p>此级别不可避免幻读，因为幻读是由于插入（insert）或者删除（delete）操作产生的。</p><h4 id="（4）串行化"><a href="#（4）串行化" class="headerlink" title="（4）串行化"></a>（4）串行化</h4><p>  这是数据库的最高隔离级别，在这种级别下，事务串行化的顺序执行。但是效率太差，基本不会使用。</p><p><strong>脏读：select问题</strong></p><p><strong>不可重复读：update问题</strong></p><p><strong>幻读：insert/delete问题</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> ORACLE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的个人博客</title>
      <link href="2020/10/28/first/"/>
      <url>2020/10/28/first/</url>
      
        <content type="html"><![CDATA[<p>欢迎大家来到我的个人博客，让我们一起学习一起进步。</p><a id="more"></a><p>我将在此更新包括但不限于：编码，设计，数据库，随笔类型的内容；如果有想和我探讨的内容，请返回首页查找合适的联系方式联系我吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> keep learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>限流算法解析</title>
      <link href="2020/10/28/current-limiting-algorithm/"/>
      <url>2020/10/28/current-limiting-algorithm/</url>
      
        <content type="html"><![CDATA[<p>引言：盘点一下常用的几种限流算法的原理与实现。</p><a id="more"></a><h2 id="1、固定时间窗口限流"><a href="#1、固定时间窗口限流" class="headerlink" title="1、固定时间窗口限流"></a>1、固定时间窗口限流</h2><p>​        固定时间窗口限流很好理解，就是使用计数器在周期内累加访问次数，当请求次数达到设定的限流值时，触发限流策略。下一个周期开始时，将计数器清零，重新计数。这种算法是限流算法中最简单的一种，无论理解还是实现。<strong>我们可以使用Redis的incr原子自增和线程安全实现</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1500511/1599120998722-dc689c17-7cc4-4b7b-ac4b-b1409ca2e224.png" alt="image.png"></p><p>​        这个算法通常用于QPS限流和统计访问总量，但对于限制粒度较大的情况下会有比较严重的临界问题：当上一个周期的100次请求在最后10ms内抵达，当前周期的100个请求在本秒的开头10ms内抵达，我们放大到周期来看，每个周期都只有100的请求量，未触发我们的限流策略，但是缩小到上个周期的最后10ms和本周期的开头10ms来看，服务器在20ms内接收到了200个请求，这个请求量超出了我们设定的限流数量，但却没有触发限流策略。</p><p>由此可见，固定时间窗口限流算法，对于粒度较大的限流周期来说，有很大的弊端。</p><h2 id="2、滑动时间窗口限流"><a href="#2、滑动时间窗口限流" class="headerlink" title="2、滑动时间窗口限流"></a>2、滑动时间窗口限流</h2><p>​        第二种是滑动时间窗口限流算法，这种算法将时间周期分为N个小周期，分别记录每个小周期内的访问次数，并且根据时间删除过期周期访问次数的记录。</p><p>如图，假设将时间周期设置为1min，我们可以将1min再划分为2个小周期，统计每个小周期内的访问次数，则可以看到，第一个周期的访问次数为75，第二个周期超过了我们限制的100，则会触发限流策略</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1500511/1599121613919-72d66c69-5832-495a-b604-0eb8260e7e76.png" alt="image.png"></p><p>由此可见，当滑动窗口划分的格子越细致，那么滑动窗口的滚动就会越平滑，限流的统计就会越精确。</p><h2 id="3、令牌桶限流"><a href="#3、令牌桶限流" class="headerlink" title="3、令牌桶限流"></a>3、令牌桶限流</h2><p>​        令牌桶也比较简单，是以程序以一个固定的速度S（S=时间周期/限流值）向令牌桶中增加令牌，直至令牌桶满，请求到达时先到令牌桶中请求令牌，获取到令牌则通过请求，否则触发限流</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1500511/1599122374364-3bb91b33-8cdb-4dcc-b574-4a965e5f8b4d.png" alt="img"></p><h2 id="4、漏桶限流"><a href="#4、漏桶限流" class="headerlink" title="4、漏桶限流"></a>4、漏桶限流</h2><p>​        漏桶限流又被成为漏斗限流，我们将访问请求直接放入漏桶，如当前容量已经达到上限，则直接触发限流。漏桶以固定的速率进行释放访问请求（即允许请求通过），直到漏桶为空。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1500511/1599122555655-41550a62-f23f-4ba6-90eb-14469639a719.png" alt="img"></p><p>附上java版的实现：</p><pre><code>/** * Created by zhangbw */public class FunnelRateLimiter {    static class Funnel {        int capacity;   //容量        float leakingRate; //速率        int leftQuota;//剩余容量        long leakingTs;//上次漏水的时间        public Funnel(int capacity, float leakingRate) {            this.capacity = capacity;            this.leakingRate = leakingRate;            this.leftQuota = capacity;            this.leakingTs = System.currentTimeMillis();        }        void makeSpace() {            long nowTs = System.currentTimeMillis();            long deltaTs = nowTs - leakingTs;//距离上一次漏水过去了多长时间            int deltaQuota = (int) (deltaTs * leakingRate);//可以腾出多少空间            //间隔时间太长 ，整数数字过大溢出            if (deltaQuota &lt; 0) {                this.leftQuota = capacity;                this.leakingTs = nowTs;                return;            }                //腾出空间太小 ，最小单位是1                if (deltaQuota &lt; 1) {                    return;                }                this.leftQuota += deltaQuota;                this.leakingTs = nowTs;                if (this.leftQuota &gt; this.capacity) {                    this.leftQuota = this.capacity;                }            }        boolean watering(int quota) {            makeSpace();            if (this.leftQuota &gt;= quota) {                this.leftQuota -= quota;                return true;            }            return false;        }        private Map&lt;String, Funnel&gt; funnels = new HashMap&lt;&gt;();        public boolean isActionAllowed(String userId, String actionKey, int capacity, float leakingRate) {            String key = String.format("%s:%s", userId, capacity);            Funnel funnel = funnels.get(key);            if (funnel == null) {                funnel = new Funnel(capacity, leakingRate);                funnels.put(key, funnel);            }            return funnel.watering(1); //需要 1 个 quota        }    }}</code></pre><p>Redis4.0为我们提供了一个限流的Redis模块，叫做<a href="https://github.com/brandur/redis-cell">Redis-Cell</a>，该模块使用了漏斗算法，并提供了原子的限流指令。我们可以直接使用。</p><p>Guava包其实对各种限流策略都有实现，详情可见：<a href="https://guava.dev/releases/19.0/api/docs/index.html?com/google/common/util/concurrent/RateLimiter.html">RateLimiter</a></p>]]></content>
      
      
      <categories>
          
          <category> 编码与设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
            <tag> java </tag>
            
            <tag> 限流 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
