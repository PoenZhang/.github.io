<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>23种设计模式（1）-创建型模式</title>
      <link href="2020/10/30/design_pattern/"/>
      <url>2020/10/30/design_pattern/</url>
      
        <content type="html"><![CDATA[<h2 id="1、单例模式"><a href="#1、单例模式" class="headerlink" title="1、单例模式"></a>1、单例模式</h2><h2 id="（1）为什么要使用单例？"><a href="#（1）为什么要使用单例？" class="headerlink" title="（1）为什么要使用单例？"></a>（1）为什么要使用单例？</h2><p>   单例模式理解起来非常简单，即一个类只允许创建一个实例（对象），那这个类就是一个单例类。这种设计模式就叫做单例模式，简称单例模式，那么单例模式可以用来解决哪些问题呢？</p><p>例1：标识全局唯一类</p><p>从业务上来讲，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类，比如配置信息类。在系统中我们只有一个配置文件，当配置文件被加载到内存以后，以对象的形式存在，就应该只有一个此类对象。</p><p>例2：ID生成器</p><p>如果程序中存在两个ID生成器对象，就有可能存在ID重复情况，所以应该将ID生成器类设计为单例模式，并且在生成id的方法上做并发处理。</p><h2 id="（2）如何实现一个单例？"><a href="#（2）如何实现一个单例？" class="headerlink" title="（2）如何实现一个单例？"></a>（2）如何实现一个单例？</h2><p>单例模式比较简单，就不再做过多赘述。网上对于如何实现一个单例也有很多的文章，在这里简单做一下描述。</p><p>生成一个单例对象，无非要保证以下几点：</p><ol><li><ol><li>类的构造函数要都是private类型的，避免从外部直接new产生对象</li><li>需要考虑对象创建的线程安全问题</li><li>考虑是否支持延迟加载</li><li>考虑getInstance()性能是否足够</li></ol></li></ol><p>创建方式有以下几种</p><ul><li><p>饿汉式</p></li><li><ul><li>在类加载的时候，instance静态实例就已经创建并初始化好了，所以instance实例的创建过程是线程安全的。不过这种的方式不支持延迟加载，导致系统启动可能会有延迟。（我个人比较推荐这种方式，一个类只要存在，就不可能不被用到）</li></ul></li></ul><pre><code>public class IdGenerator {   private AtomicLong id = new AtomicLong(0);  private static final IdGenerator instance = new IdGenerator();  private IdGenerator() {}  public static IdGenerator getInstance() {    return instance;  }  public long getId() {     return id.incrementAndGet();  }}</code></pre><ul><li><p>懒汉式</p></li><li><ul><li>懒汉式相对于饿汉式的优势就是支持延迟加载，但缺点也很明显，引入了线程安全问题，需要在创建实例的方法上加锁</li></ul></li></ul><pre><code>public class IdGenerator {   private AtomicLong id = new AtomicLong(0);  private static IdGenerator instance;  private IdGenerator() {}  public static synchronized IdGenerator getInstance() {    if (instance == null) {      instance = new IdGenerator();    }    return instance;  }  public long getId() {     return id.incrementAndGet();  }}</code></pre><ul><li><p>双重检测</p></li><li><ul><li>饿汉式不支持延迟加载，懒汉式会有线程安全问题和并发度问题，有没有一种方式既支持延迟加载，又能在性能有保证的方法呢？答案就是双重检测（Double-Check）。在这种方法中，只有instance被创建之后，即便再调用getInstance方法也不会在进入到加锁逻辑了。但下边的实现方式还是有问题，因为编译器在自动优化的时候会指令重排，有可能会导致IdGeneratoe对象被new出来并且赋值给instance之后，进行初始化（执行构造方法的逻辑）之前，就被另一个线程使用了（这种现象叫做逸出）。要解决这个问题也很简单，给instance对象加上volatile关键字即可（volatile禁止重排，并且在并发情况下，保证变量在修改之后，立刻对其他线程可见）</li></ul></li></ul><pre><code>public class IdGenerator {   private AtomicLong id = new AtomicLong(0);  private static IdGenerator instance;  private IdGenerator() {}  public static IdGenerator getInstance() {    if (instance == null) {      synchronized(IdGenerator.class) { // 此处为类级别的锁        if (instance == null) {          instance = new IdGenerator();        }      }    }    return instance;  }  public long getId() {     return id.incrementAndGet();  }}</code></pre><ul><li><p>内部静态类</p></li><li><ul><li>有点类似饿汉式，但又能做到延迟加载</li></ul></li></ul><pre><code>public class IdGenerator {   private AtomicLong id = new AtomicLong(0);  private IdGenerator() {}  private static class SingletonHolder{    private static final IdGenerator instance = new IdGenerator();  }  public static IdGenerator getInstance() {    return SingletonHolder.instance;  }  public long getId() {     return id.incrementAndGet();  }}</code></pre><p>SingletonHoler是一个内部静态，当加载外部类的时候，并不会创建SingletonHoler对象，只有当调用getinstance方法的是，Holder才会被加载，这个时候创建instance。</p><ul><li>枚举</li></ul><pre><code>public enum IdGenerator {  INSTANCE;  private AtomicLong id = new AtomicLong(0);  public long getId() {     return id.incrementAndGet();  }}</code></pre><h2 id="2、工厂模式"><a href="#2、工厂模式" class="headerlink" title="2、工厂模式"></a>2、工厂模式</h2><p>工厂模式也是经常见到的模式之一，一般情况下，工厂模式可以分为三种更加细分的类型：简单工厂，工厂方法和抽象工厂。</p><h3 id="（1）简单工厂"><a href="#（1）简单工厂" class="headerlink" title="（1）简单工厂"></a>（1）简单工厂</h3><p>举个例子，如果我们需要根据配置项目中配置文件的后缀，选择不同的配置解析器，将存储在配置文件中的数据解析成内存对象，简单方法如下：</p><pre><code>public class RuleConfigSource {  public RuleConfig load(String ruleConfigFilePath) {    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);    IRuleConfigParser parser = null;    if ("json".equalsIgnoreCase(ruleConfigFileExtension)) {      parser = new JsonRuleConfigParser();    } else if ("xml".equalsIgnoreCase(ruleConfigFileExtension)) {      parser = new XmlRuleConfigParser();    } else if ("yaml".equalsIgnoreCase(ruleConfigFileExtension)) {      parser = new YamlRuleConfigParser();    } else if ("properties".equalsIgnoreCase(ruleConfigFileExtension)) {      parser = new PropertiesRuleConfigParser();    } else {      throw new InvalidRuleConfigException(             "Rule config file format is not supported: " + ruleConfigFilePath);    }    String configText = "";    //从ruleConfigFilePath文件中读取配置文本到configText中    RuleConfig ruleConfig = parser.parse(configText);    return ruleConfig;  }  private String getFileExtension(String filePath) {    //...解析文件名获取扩展名，比如rule.json，返回json    return "json";  }}</code></pre><p>但是一个好的代码设计，为了让逻辑更加清晰，可读性更好，我们首先要去掉大量繁杂的分支逻辑，将功能独立的代码块封装成函数，按照这个逻辑，我们可以将创建parser的逻辑剥离出来，行成createParser函数：</p><pre><code>  public RuleConfig load(String ruleConfigFilePath) {    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);    IRuleConfigParser parser = createParser(ruleConfigFileExtension);    if (parser == null) {      throw new InvalidRuleConfigException(              "Rule config file format is not supported: " + ruleConfigFilePath);    }    String configText = "";    //从ruleConfigFilePath文件中读取配置文本到configText中    RuleConfig ruleConfig = parser.parse(configText);    return ruleConfig;  }  private String getFileExtension(String filePath) {    //...解析文件名获取扩展名，比如rule.json，返回json    return "json";  }  private IRuleConfigParser createParser(String configFormat) {    IRuleConfigParser parser = null;    if ("json".equalsIgnoreCase(configFormat)) {      parser = new JsonRuleConfigParser();    } else if ("xml".equalsIgnoreCase(configFormat)) {      parser = new XmlRuleConfigParser();    } else if ("yaml".equalsIgnoreCase(configFormat)) {      parser = new YamlRuleConfigParser();    } else if ("properties".equalsIgnoreCase(configFormat)) {      parser = new PropertiesRuleConfigParser();    }    return parser;  }}</code></pre><p>到这里还不够，本着职责单一原则，我们将createParser函数剥离到一个单独的类中，让这个类只负责Parser类的创建，那么这个类，就可以被称为简单工厂：</p><pre><code>public class RuleConfigSource {  public RuleConfig load(String ruleConfigFilePath) {    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);    IRuleConfigParser parser = RuleConfigParserFactory.createParser(ruleConfigFileExtension);    if (parser == null) {      throw new InvalidRuleConfigException(              "Rule config file format is not supported: " + ruleConfigFilePath);    }    String configText = "";    //从ruleConfigFilePath文件中读取配置文本到configText中    RuleConfig ruleConfig = parser.parse(configText);    return ruleConfig;  }  private String getFileExtension(String filePath) {    //...解析文件名获取扩展名，比如rule.json，返回json    return "json";  }}public class RuleConfigParserFactory {  public static IRuleConfigParser createParser(String configFormat) {    IRuleConfigParser parser = null;    if ("json".equalsIgnoreCase(configFormat)) {      parser = new JsonRuleConfigParser();    } else if ("xml".equalsIgnoreCase(configFormat)) {      parser = new XmlRuleConfigParser();    } else if ("yaml".equalsIgnoreCase(configFormat)) {      parser = new YamlRuleConfigParser();    } else if ("properties".equalsIgnoreCase(configFormat)) {      parser = new PropertiesRuleConfigParser();    }    return parser;  }}</code></pre><p>还有没有优化的空间？对于一个解析类来说，是解析完即弃的，对于这样的跟数据无关的工具类，我们完全可以缓存一份，第一次创建之后缓存起来，第二次再请求直接返回。</p><p>缺点在哪里？</p><ul><li>违反开闭原则：如果我们要增加新的解析规则，那么就要更改到createParser方法，增加新的if/else分支</li><li>大量繁杂的分支逻辑：可读性和维护性降低</li></ul><h3 id="（2）工厂方法"><a href="#（2）工厂方法" class="headerlink" title="（2）工厂方法"></a>（2）工厂方法</h3><p>如果我们非要将if/else分支逻辑取消，该怎么做？</p><p>多态写法如下：</p><pre><code>public interface IRuleConfigParserFactory {  IRuleConfigParser createParser();}public class JsonRuleConfigParserFactory implements IRuleConfigParserFactory {  @Override  public IRuleConfigParser createParser() {    return new JsonRuleConfigParser();  }}public class XmlRuleConfigParserFactory implements IRuleConfigParserFactory {  @Override  public IRuleConfigParser createParser() {    return new XmlRuleConfigParser();  }}public class YamlRuleConfigParserFactory implements IRuleConfigParserFactory {  @Override  public IRuleConfigParser createParser() {    return new YamlRuleConfigParser();  }}public class PropertiesRuleConfigParserFactory implements IRuleConfigParserFactory {  @Override  public IRuleConfigParser createParser() {    return new PropertiesRuleConfigParser();  }}</code></pre><p>这样写的话，我们如果要增加新的解析类的话，只要新增接口的实现类即可，符合开闭原则，但是使用的时候如何使用？</p><pre><code>public class RuleConfigSource {  public RuleConfig load(String ruleConfigFilePath) {    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);    IRuleConfigParserFactory parserFactory = null;    if ("json".equalsIgnoreCase(ruleConfigFileExtension)) {      parserFactory = new JsonRuleConfigParserFactory();    } else if ("xml".equalsIgnoreCase(ruleConfigFileExtension)) {      parserFactory = new XmlRuleConfigParserFactory();    } else if ("yaml".equalsIgnoreCase(ruleConfigFileExtension)) {      parserFactory = new YamlRuleConfigParserFactory();    } else if ("properties".equalsIgnoreCase(ruleConfigFileExtension)) {      parserFactory = new PropertiesRuleConfigParserFactory();    } else {      throw new InvalidRuleConfigException("Rule config file format is not supported: " + ruleConfigFilePath);    }    IRuleConfigParser parser = parserFactory.createParser();    String configText = "";    //从ruleConfigFilePath文件中读取配置文本到configText中    RuleConfig ruleConfig = parser.parse(configText);    return ruleConfig;  }  private String getFileExtension(String filePath) {    //...解析文件名获取扩展名，比如rule.json，返回json    return "json";  }}</code></pre><p>可以看到创建解析对象的方法又耦合进了load函数中，其实跟第一种方式没有太大区别，反而看起来更复杂了。</p><p>我们可以为工厂类再创建一个简单工厂，看代码：</p><pre><code>public class RuleConfigSource {  public RuleConfig load(String ruleConfigFilePath) {    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);    IRuleConfigParserFactory parserFactory = RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);    if (parserFactory == null) {      throw new InvalidRuleConfigException("Rule config file format is not supported: " + ruleConfigFilePath);    }    IRuleConfigParser parser = parserFactory.createParser();    String configText = "";    //从ruleConfigFilePath文件中读取配置文本到configText中    RuleConfig ruleConfig = parser.parse(configText);    return ruleConfig;  }  private String getFileExtension(String filePath) {    //...解析文件名获取扩展名，比如rule.json，返回json    return "json";  }}//因为工厂类只包含方法，不包含成员变量，完全可以复用，//不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。public class RuleConfigParserFactoryMap { //工厂的工厂  private static final Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories = new HashMap&lt;&gt;();  static {    cachedFactories.put("json", new JsonRuleConfigParserFactory());    cachedFactories.put("xml", new XmlRuleConfigParserFactory());    cachedFactories.put("yaml", new YamlRuleConfigParserFactory());    cachedFactories.put("properties", new PropertiesRuleConfigParserFactory());  }  public static IRuleConfigParserFactory getParserFactory(String type) {    if (type == null || type.isEmpty()) {      return null;    }    IRuleConfigParserFactory parserFactory = cachedFactories.get(type.toLowerCase());    return parserFactory;  }}</code></pre><p>但其实看起来，也没有太大的必要多加IRuleConfigParserFactory这一层，只缓存文件类型和对应的解析类也行，但是这段代码，如果需要新增解析类，那么完全不用修改调用的地方，只需要修改RuleConfigParserFactoryMap就行了，对于客户端来说，屏蔽了服务端的变化</p><h3 id="（3）抽象工厂（不重要）"><a href="#（3）抽象工厂（不重要）" class="headerlink" title="（3）抽象工厂（不重要）"></a>（3）抽象工厂（不重要）</h3><p>在简单工厂和工厂方法中，类只有一个分类方式。比如在规则配置解析的例子中，解析类只会根据配置文件格式来分类，但是如果类有两种分类方式，比如既可以按照配置文件格式来分类，也可以按照解析的对象来分类，那么就会有8个parser类，再多就组合爆炸：</p><pre><code>针对规则配置的解析器：基于接口IRuleConfigParserJsonRuleConfigParserXmlRuleConfigParserYamlRuleConfigParserPropertiesRuleConfigParser针对系统配置的解析器：基于接口ISystemConfigParserJsonSystemConfigParserXmlSystemConfigParserYamlSystemConfigParserPropertiesSystemConfigParser</code></pre><p>针对这种场景，我们可以让一个工厂负责创建多个不通过的类型的对象，而不是只会创建一种parser，代码如下：</p><pre><code>public interface IConfigParserFactory {  IRuleConfigParser createRuleParser();  ISystemConfigParser createSystemParser();  //此处可以扩展新的parser类型，比如IBizConfigParser}public class JsonConfigParserFactory implements IConfigParserFactory {  @Override  public IRuleConfigParser createRuleParser() {    return new JsonRuleConfigParser();  }  @Override  public ISystemConfigParser createSystemParser() {    return new JsonSystemConfigParser();  }}public class XmlConfigParserFactory implements IConfigParserFactory {  @Override  public IRuleConfigParser createRuleParser() {    return new XmlRuleConfigParser();  }  @Override  public ISystemConfigParser createSystemParser() {    return new XmlSystemConfigParser();  }}// 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码</code></pre><p>更加通用的方式就是更加抽象！</p><h2 id="3、建造者模式"><a href="#3、建造者模式" class="headerlink" title="3、建造者模式"></a>3、建造者模式</h2><p>Builder模式，中文翻译为建造者模式或者构建者模式，生成器模式，原理非常简单。</p><p>现在有一个复杂的对象需要创建，对象的属性有几十个，如果按照我们传统的set方式，那么我们要在new出来一个对象之后，写十几个set方法或者写一个参数究极长的构造函数，有以下缺点：</p><ul><li>参数太长，对于一些不必填的参数，需要用null来占位</li><li>如果参数有依赖关系，比如设置了一个就必须设置另一个，如何处理？</li><li>如果我们希望这个类为不可变对象，即创建完就不能再被修改，name我们就不能暴露set方法。该如何处理</li></ul><p>为了解决这些问题，构建者模式就排上用场了。我们将校验逻辑放到Builer类中，先创建建造和，并且通过set方法设置建造者的变量值，然后在使用build方法真正创建对象之前，做集中的校验，将目标对象的构造方法设置为私有，并且不提供set方法，代码示例如下：</p><pre><code>public class ResourcePoolConfig {  private String name;  private int maxTotal;  private int maxIdle;  private int minIdle;  private ResourcePoolConfig(Builder builder) {    this.name = builder.name;    this.maxTotal = builder.maxTotal;    this.maxIdle = builder.maxIdle;    this.minIdle = builder.minIdle;  }  //...省略getter方法...  //我们将Builder类设计成了ResourcePoolConfig的内部类。  //我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。  public static class Builder {    private static final int DEFAULT_MAX_TOTAL = 8;    private static final int DEFAULT_MAX_IDLE = 8;    private static final int DEFAULT_MIN_IDLE = 0;    private String name;    private int maxTotal = DEFAULT_MAX_TOTAL;    private int maxIdle = DEFAULT_MAX_IDLE;    private int minIdle = DEFAULT_MIN_IDLE;    public ResourcePoolConfig build() {      // 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等      if (StringUtils.isBlank(name)) {        throw new IllegalArgumentException("...");      }      if (maxIdle &gt; maxTotal) {        throw new IllegalArgumentException("...");      }      if (minIdle &gt; maxTotal || minIdle &gt; maxIdle) {        throw new IllegalArgumentException("...");      }      return new ResourcePoolConfig(this);    }    public Builder setName(String name) {      if (StringUtils.isBlank(name)) {        throw new IllegalArgumentException("...");      }      this.name = name;      return this;    }    public Builder setMaxTotal(int maxTotal) {      if (maxTotal &lt;= 0) {        throw new IllegalArgumentException("...");      }      this.maxTotal = maxTotal;      return this;    }    public Builder setMaxIdle(int maxIdle) {      if (maxIdle &lt; 0) {        throw new IllegalArgumentException("...");      }      this.maxIdle = maxIdle;      return this;    }    public Builder setMinIdle(int minIdle) {      if (minIdle &lt; 0) {        throw new IllegalArgumentException("...");      }      this.minIdle = minIdle;      return this;    }  }}// 这段代码会抛出IllegalArgumentException，因为minIdle&gt;maxIdleResourcePoolConfig config = new ResourcePoolConfig.Builder()        .setName("dbconnectionpool")        .setMaxTotal(16)        .setMaxIdle(10)        .setMinIdle(12)        .build();</code></pre><p>与工厂模式有何区别？</p><p>我们可以看出，建造者模式是让建造者类来负责对象的创建工作，而工厂模式是让工厂类来负责创建的工作。</p><p>区别在于：工厂模式市创建不同但是相关类型的对象，由给定的参数来决定创建那种类型的对象；而建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，定制化不同的复杂对象</p><p>网上有一个经典例子：</p><p>顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。实际上，我们也不要太学院派，非得把工厂模式、建造者模式分得那么清楚，我们需要知道的是，每个模式为什么这么设计，能解决什么问题。只有了解了这些最本质的东西，我们才能不生搬硬套，才能灵活应用，甚至可以混用各种模式创造出新的模式，来解决特定场景的问题。</p><h2 id="4、原型模式"><a href="#4、原型模式" class="headerlink" title="4、原型模式"></a>4、原型模式</h2><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大，在这种情况下，我们可以利用对已有对象进行复制的方式来创建新对象，以达到节省创建时间的摸底，这种基于原型来创建对象的方式叫做原型设计模式</p><p>那怎么样才能叫做“对象的创建成本比较大”？</p><p>实际上，对象创建时申请内存，给属性赋值的耗时并不会太大，或者对于大部分业务系统来说，这点时间完全是可以忽略的，为了一点点的性能提升去应用一个复杂的设计模式，是得不偿失的。</p><p>但是，如果对象的获得需要经过复杂的计算才能得到，比如哈希，排序，或者需要从RPC，网络，数据库或者文件等非常慢的IO读取，这种情况下，我们就可以利用原型模式，从其他对象中直接拷贝，而不用每次在创建新对象的时候，都重复执行这些耗时的操作。</p><p>实现方式：<strong>深拷贝和浅拷贝</strong></p><p><strong>浅拷贝</strong>：浅拷贝只会复制对象中的引用，即复制了一下地址，将复制出来的对象指向原对象的地址。浅拷贝出来的对象跟源对象都指向同一块内存区域。浅拷贝只会拷贝对象中的基本数据类型的数据和引用对象的内存地址，不会递归的拷贝引用对象本身</p><p><strong>深拷贝</strong>：深拷贝是得到一份完全独立的对象，另申请一块内存存储这些数据，会递归的拷贝引用对线跟本身。深拷贝的实现方式有两种，一种是递归的拷贝引用对象，一种是将源对象序列化，在反序列化成一个新对象。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1500511/1598602444217-7b35d624-2456-408a-84c1-3a696d835fc8.jpeg?x-oss-process=image/resize,w_1500" alt="image"></p><p><em>设计模式系列都是极客时间学习略作总结，原课程可以</em><a href="https://time.geekbang.org/column/intro/250?utm_campaign=guanwang&amp;utm_source=baidu-ad&amp;utm_medium=ppzq-pc&amp;utm_content=title&amp;utm_term=baidu-ad-ppzq-title"><em>点击</em></a><em>购买</em></p>]]></content>
      
      
      <categories>
          
          <category> 编码与设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用SQL的EXPLAIN指令判断和优化SQL性能？</title>
      <link href="2020/10/29/EXPALIN/"/>
      <url>2020/10/29/EXPALIN/</url>
      
        <content type="html"><![CDATA[<p>工作中，我们经常会写一些很复杂的SQL，有可能是统计报表，有可能是复杂查询，当我们费尽手段把一个可以工作的SQL写出来之后，并不意味着结束了，如果这个SQL查询或者统计速度很慢，将是一个十分耗费资源的动作。即使它能工作，也有可能在执行半分钟或者更久之后能够给出结果，但执行时间越久，耗费资源就越多，越容易阻塞后续的数据库链接请求，如果这样的SQL很多，那么最终也将拖垮服务器。</p><h3 id="EXPALIN指令"><a href="#EXPALIN指令" class="headerlink" title="EXPALIN指令"></a>EXPALIN指令</h3><p>SQL为什么会执行的慢？该如何判断这个SQL的查询数量级？我们可以用 “EXPLAIN”指令，解释你的SQL。</p><p>EXPLAIN指令是一个优化神器，虽然它并不能直接告诉你该如何优化这个SQL，但是你可以根据它对你SQL的模拟执行得到你的SQL有没有用上索引，有没有做全表扫描，查询出结果的数量级是多少。这是一个基于开销的优化器，我们可以获得更多被优化器考虑到的访问策略的细节，以及当运行SQL语句时，哪种策略预计会被采用。</p><pre><code>mysql&gt; explain select * from servers;+----+-------------+---------+------+---------------+------+---------+------+------+-------+| id | select_type | table   | type | possible_keys | key  | key_len | ref  | rows | Extra |+----+-------------+---------+------+---------------+------+---------+------+------+-------+|  1 | SIMPLE      | servers | ALL  | NULL          | NULL | NULL    | NULL |    1 | NULL  |+----+-------------+---------+------+---------------+------+---------+------+------+-------+row in set (0.03 sec)</code></pre><p>我们做了一个简单的例子，我们可以看到explain的用法就是 “explain 目标SQL”，得出的结果有10列，如上代码块，我们会挨个解释这些列的意义。</p><h4 id="1、id"><a href="#1、id" class="headerlink" title="1、id"></a>1、id</h4><p>这个id并不是表中记录的id，而是查询语句或者操作表的顺序，包含几种情况</p><p>id相同时，执行顺序由上到下</p><p>id不同，如果是子查询，id序号会递增，id越大优先级越高，越先被执行</p><p>id既有相同的，也有不同的。id相同的被认为是一组，顺序从上到下；在所有组中，id越大优先级越高。</p><h4 id="2、select-type"><a href="#2、select-type" class="headerlink" title="2、select type"></a>2、select type</h4><p>表示查询中每个select字句的类型</p><p>（1）simple：简单select，不使用union或子查询等</p><p>（2）primary：查询中若包含任何复杂的子部分，最外层的select会被标记为primary</p><p>（3）union：union中的第二个或者后边的select语句</p><p>（4）subquery：在select或者where中包含了子查询</p><p>（5）derived：在from列表中包含的子查询被标记为derived（衍生表），mysql会递归这些子查询并放到临时表中</p><p>（6）union result:从union表中获取select查询的结果</p><h4 id="3、table"><a href="#3、table" class="headerlink" title="3、table"></a>3、table</h4><p>标识这一行的数据是关于哪一张表的，有的时候并不是真实的表名，比如是derived衍生表</p><pre><code>mysql&gt; explain select * from (select * from ( select * from t1 where id=2602) a) b;+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+| id | select_type | table      | type   | possible_keys     | key     | key_len | ref  | rows | Extra |+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+|  1 | PRIMARY     | &lt;derived2&gt; | system | NULL              | NULL    | NULL    | NULL |    1 |       ||  2 | DERIVED     | &lt;derived3&gt; | system | NULL              | NULL    | NULL    | NULL |    1 |       ||  3 | DERIVED     | t1         | const  | PRIMARY,idx_t1_id | PRIMARY | 4       |      |    1 |       |+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+</code></pre><h4 id="4、type"><a href="#4、type" class="headerlink" title="4、type"></a>4、type</h4><p>表示在表中找到所需行的方式，又叫做访问类型。常用的类型由：all，index，range，ref，eq_ref，const，system，null（性能从差到好）</p><p>all:：全表扫描</p><p>index：index和all的区别是index只遍历索引树</p><p>range：只检索给定范围的行记录，使用一个索引来选择行</p><p>ref：表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p><p>eq_ref：跟ref类似，区别在于使用的索引是唯一索引</p><p>sonst，system：当SQL对查询部分进行优化，并转换为一个常量时，使用这些类型访问。</p><p>null：在优化过程中分解语句，执行时甚至不用访问表或者索引。例如从一个索引列中选取最小值可以单独通过索引查找完成。</p><h4 id="5、possible-keys"><a href="#5、possible-keys" class="headerlink" title="5、possible_keys"></a>5、possible_keys</h4><p>指出能使用哪个索引在表中找到记录，查询涉及的字段若存在索引，会在这一列列出来，但不一定会用到该索引。</p><p>如果该列是null，就说明没有用到任何索引，这时候你可能需要观察表中的查询高频列增加索引，然后在explain看下结果</p><h4 id="6、keys"><a href="#6、keys" class="headerlink" title="6、keys"></a>6、keys</h4><p>显示实际决定使用的索引列</p><p>如果没有选择到索引，则是null。如果要强制使用某个索引，需要在查询中加语句：force index，use index。如果不想使用某索引，可以使用 ignore index </p><h4 id="7、key-len"><a href="#7、key-len" class="headerlink" title="7、key_len"></a>7、key_len</h4><p>表示索引中使用的字节数，可以通过该列计算查询中使用的索引长度</p><h4 id="8、ref"><a href="#8、ref" class="headerlink" title="8、ref"></a>8、ref</h4><p>表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。</p><h4 id="9、rows"><a href="#9、rows" class="headerlink" title="9、rows"></a>9、rows</h4><p>标识此次查询根据表统计信息及索引选用情况，估算到的找到符合条件的记录所需要读取的行数</p><h4 id="10、extra"><a href="#10、extra" class="headerlink" title="10、extra"></a>10、extra</h4><p>包含此次查询的详细信息：</p><p>using filesort：表明此次查询会使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。查询中无法利用索引完成的排序被称为文件排序</p><p>using temporary：此次查询使用到了临时表保存中间结果，常见于order by和group by</p><p>using index：表明此次查询实用到了覆盖索引，避免了全表扫描</p><p>using where：表明此次查询where的条件里边，有索引值存在，使用到了索引去查询</p><p>using join buffer：使用了链接缓存</p><p>impossible where：where条件里边总是false，不能用来获取任何记录</p><p>select tables optimized away：这意味着仅通过使用索引，优化器可能仅从聚合函数中返回一行</p><p>explain指令，不会考虑各种cache，也不会告诉你它做了什么优化，也只能支持select操作，部分的统计信息是估算的，并非精确值。</p><p>我们使用explain的时候，在大部分情况下都是要关注：<strong>possible_keys，**</strong>Key，**<strong>rows，**</strong>Extra<strong>这四项，关注此次查询</strong>是否用到了索引，大约查询的数据在什么量级，额外用到了哪些东西**，这是我们着重优化的点。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> ORACLE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库事务隔离级别</title>
      <link href="2020/10/29/data_transaction/"/>
      <url>2020/10/29/data_transaction/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是事务隔离？"><a href="#什么是事务隔离？" class="headerlink" title="什么是事务隔离？"></a>什么是事务隔离？</h3><p>任何支持事务的数据库，都必须具备四个特性：原子性，一致性，隔离性，永久性，也就是ACID，这样才能保证事务中数据的正确性。</p><p>而事务的隔离性就是指：多个并发的事务同事访问一个数据库时，一个事务不应该被另一个事务所干扰，每个并发的事务都要相互隔离。</p><h3 id="如果没有事务隔离"><a href="#如果没有事务隔离" class="headerlink" title="如果没有事务隔离"></a>如果没有事务隔离</h3><p>如果没有事务隔离的话，会发生什么？</p><p>假设有表T，里边记录了几种语言的记录</p><table><thead><tr><th>ID</th><th>NAME</th></tr></thead><tbody><tr><td>1</td><td>JavaWeb</td></tr><tr><td>2</td><td>Python</td></tr><tr><td>3</td><td>Go</td></tr></tbody></table><p>（1）事务A访问数据库，向表中插入了一条记录4:C++，但是并没有提交事务</p><p>insert into T values(4,’C++’)；</p><p>这时候，来了一个事务B，要查询表中所有的记录，这是就能查到id为4的C++，这种情况叫做“脏读”</p><p>（2）事务A访问数据库，要按id查询id为1的语言的名字，执行了：</p><pre><code>select * from T where id = 1;</code></pre><p>得到了name为JavaWeb的记录。这时候事务B访问数据库，将id为1的记录的name更新为了JavaEE</p><pre><code>update T set name = 'JavaEE' where id = 1;</code></pre><p>接着事务A还想再看一次id为1的记录的name，发现已经变成了JavaEE，跟第一次的读取数据不同，这就叫做不可重复读。</p><p>（3）事务A访问数据库，想看表中的记录都有什么，于是执行了：</p><pre><code>select * from T;</code></pre><p>这时候，事务B来了，向表中插入了一条新的记录：</p><pre><code>insert into A values(5,'SQL');</code></pre><p>然后事务A想再查看一遍刚才的语言都有哪些，于是把刚才的查询语句又执行了一遍，结果第一次查询有四条，第二次查询有五条。这叫幻读。</p><h3 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h3><p>为了解决以上 脏读，不可重复读，幻读的问题，我们需要根据我们的实际情况来设置数据库的隔离级别：</p><ul><li>读未提交</li><li>读提交</li><li>可重复读</li><li>串行化</li></ul><p>这四种隔离级别对应着三种事务隔离问题，下面看一下具体解释：</p><h4 id="（1）读未提交"><a href="#（1）读未提交" class="headerlink" title="（1）读未提交"></a>（1）读未提交</h4><p>就是可以读到未提交的内容。因此在这种级别下，是不会加锁的，就会导致脏读的情况，当然了，也会出现不可重复读和幻读。</p><h4 id="（2）读提交"><a href="#（2）读提交" class="headerlink" title="（2）读提交"></a>（2）读提交</h4><p>就是只能读到事务已经提交的内容。这是各种系统中最常用的一种隔离级别。包括SQL Server和Oracle。这种隔离级别可以避免脏读。</p><p>这个级别也可以叫做“快照读”，这是按照原理来命名的，即：是事务中的每个 sql 语句生成一个 readView。那就是一个事务内多条 sql 语句，会生成多个 readView。而每条 sql 执行时，都是查询最新 readView 的值，从而查取到别的事务已经提交的数据。</p><p>但是读已提交只能避免脏读，而无法解决不可重复读和幻读。</p><h4 id="（3）可重复读"><a href="#（3）可重复读" class="headerlink" title="（3）可重复读"></a>（3）可重复读</h4><p>专门针对不可重复读的隔离级别，是MySQL的默认隔离级别。</p><p>在这个级别下，普通的查询依然是快照读，但是在事务启动时，就不允许修改（Update）操作了，而不可重复读正是因为两次读取之间出现了数据的修改操作，读取之后就加锁不允许其他事务修改这种操作效率也比较差，而成熟的数据库，出于性能考虑，都是使用了以乐观锁为理论基础的<strong>MVCC（多版本并发控制）</strong>来实现。</p><p>此级别不可避免幻读，因为幻读是由于插入（insert）或者删除（delete）操作产生的。</p><h4 id="（4）串行化"><a href="#（4）串行化" class="headerlink" title="（4）串行化"></a>（4）串行化</h4><p>  这是数据库的最高隔离级别，在这种级别下，事务串行化的顺序执行。但是效率太差，基本不会使用。</p><p><strong>脏读：select问题</strong></p><p><strong>不可重复读：update问题</strong></p><p><strong>幻读：insert/delete问题</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> ORACLE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的个人博客</title>
      <link href="2020/10/28/first/"/>
      <url>2020/10/28/first/</url>
      
        <content type="html"><![CDATA[<p>欢迎大家来到我的个人博客，让我们一起学习一起进步。</p><a id="more"></a><p>我将在此更新包括但不限于：编码，设计，数据库，随笔类型的内容；如果有想和我探讨的内容，请返回首页查找合适的联系方式联系我吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> keep learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>限流算法解析</title>
      <link href="2020/10/28/current-limiting-algorithm/"/>
      <url>2020/10/28/current-limiting-algorithm/</url>
      
        <content type="html"><![CDATA[<p>引言：盘点一下常用的几种限流算法的原理与实现。</p><a id="more"></a><h2 id="1、固定时间窗口限流"><a href="#1、固定时间窗口限流" class="headerlink" title="1、固定时间窗口限流"></a>1、固定时间窗口限流</h2><p>​        固定时间窗口限流很好理解，就是使用计数器在周期内累加访问次数，当请求次数达到设定的限流值时，触发限流策略。下一个周期开始时，将计数器清零，重新计数。这种算法是限流算法中最简单的一种，无论理解还是实现。<strong>我们可以使用Redis的incr原子自增和线程安全实现</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1500511/1599120998722-dc689c17-7cc4-4b7b-ac4b-b1409ca2e224.png" alt="image.png"></p><p>​        这个算法通常用于QPS限流和统计访问总量，但对于限制粒度较大的情况下会有比较严重的临界问题：当上一个周期的100次请求在最后10ms内抵达，当前周期的100个请求在本秒的开头10ms内抵达，我们放大到周期来看，每个周期都只有100的请求量，未触发我们的限流策略，但是缩小到上个周期的最后10ms和本周期的开头10ms来看，服务器在20ms内接收到了200个请求，这个请求量超出了我们设定的限流数量，但却没有触发限流策略。</p><p>由此可见，固定时间窗口限流算法，对于粒度较大的限流周期来说，有很大的弊端。</p><h2 id="2、滑动时间窗口限流"><a href="#2、滑动时间窗口限流" class="headerlink" title="2、滑动时间窗口限流"></a>2、滑动时间窗口限流</h2><p>​        第二种是滑动时间窗口限流算法，这种算法将时间周期分为N个小周期，分别记录每个小周期内的访问次数，并且根据时间删除过期周期访问次数的记录。</p><p>如图，假设将时间周期设置为1min，我们可以将1min再划分为2个小周期，统计每个小周期内的访问次数，则可以看到，第一个周期的访问次数为75，第二个周期超过了我们限制的100，则会触发限流策略</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1500511/1599121613919-72d66c69-5832-495a-b604-0eb8260e7e76.png" alt="image.png"></p><p>由此可见，当滑动窗口划分的格子越细致，那么滑动窗口的滚动就会越平滑，限流的统计就会越精确。</p><h2 id="3、令牌桶限流"><a href="#3、令牌桶限流" class="headerlink" title="3、令牌桶限流"></a>3、令牌桶限流</h2><p>​        令牌桶也比较简单，是以程序以一个固定的速度S（S=时间周期/限流值）向令牌桶中增加令牌，直至令牌桶满，请求到达时先到令牌桶中请求令牌，获取到令牌则通过请求，否则触发限流</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1500511/1599122374364-3bb91b33-8cdb-4dcc-b574-4a965e5f8b4d.png" alt="img"></p><h2 id="4、漏桶限流"><a href="#4、漏桶限流" class="headerlink" title="4、漏桶限流"></a>4、漏桶限流</h2><p>​        漏桶限流又被成为漏斗限流，我们将访问请求直接放入漏桶，如当前容量已经达到上限，则直接触发限流。漏桶以固定的速率进行释放访问请求（即允许请求通过），直到漏桶为空。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1500511/1599122555655-41550a62-f23f-4ba6-90eb-14469639a719.png" alt="img"></p><p>附上java版的实现：</p><pre><code>/** * Created by zhangbw */public class FunnelRateLimiter {    static class Funnel {        int capacity;   //容量        float leakingRate; //速率        int leftQuota;//剩余容量        long leakingTs;//上次漏水的时间        public Funnel(int capacity, float leakingRate) {            this.capacity = capacity;            this.leakingRate = leakingRate;            this.leftQuota = capacity;            this.leakingTs = System.currentTimeMillis();        }        void makeSpace() {            long nowTs = System.currentTimeMillis();            long deltaTs = nowTs - leakingTs;//距离上一次漏水过去了多长时间            int deltaQuota = (int) (deltaTs * leakingRate);//可以腾出多少空间            //间隔时间太长 ，整数数字过大溢出            if (deltaQuota &lt; 0) {                this.leftQuota = capacity;                this.leakingTs = nowTs;                return;            }                //腾出空间太小 ，最小单位是1                if (deltaQuota &lt; 1) {                    return;                }                this.leftQuota += deltaQuota;                this.leakingTs = nowTs;                if (this.leftQuota &gt; this.capacity) {                    this.leftQuota = this.capacity;                }            }        boolean watering(int quota) {            makeSpace();            if (this.leftQuota &gt;= quota) {                this.leftQuota -= quota;                return true;            }            return false;        }        private Map&lt;String, Funnel&gt; funnels = new HashMap&lt;&gt;();        public boolean isActionAllowed(String userId, String actionKey, int capacity, float leakingRate) {            String key = String.format("%s:%s", userId, capacity);            Funnel funnel = funnels.get(key);            if (funnel == null) {                funnel = new Funnel(capacity, leakingRate);                funnels.put(key, funnel);            }            return funnel.watering(1); //需要 1 个 quota        }    }}</code></pre><p>Redis4.0为我们提供了一个限流的Redis模块，叫做<a href="https://github.com/brandur/redis-cell">Redis-Cell</a>，该模块使用了漏斗算法，并提供了原子的限流指令。我们可以直接使用。</p><p>Guava包其实对各种限流策略都有实现，详情可见：<a href="https://guava.dev/releases/19.0/api/docs/index.html?com/google/common/util/concurrent/RateLimiter.html">RateLimiter</a></p>]]></content>
      
      
      <categories>
          
          <category> 编码与设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
            <tag> java </tag>
            
            <tag> 限流 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
